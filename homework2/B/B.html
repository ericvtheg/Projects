<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js - gpu particle system</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: Monospace;
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden;
	}
	#info {
		position: absolute;
		top: 0px;
		width: 100%;
		padding: 5px;
		font-family:Monospace;
		font-size:13px;
		text-align:center;
		color: #ffffff;
	}
	a {
		color: #ffffff;
	}
	</style>
</head>

<body>

	<div id="container"></div>
	<script src="./build/three.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="./js/libs/dat.gui.min.js"></script>
	<script src="./js/libs/stats.min.js"></script>
	<script src="./js/GPUParticleSystem.js"></script>

	<script>
	
		var camera, tick = 0,scene, renderer, clock = new THREE.Clock(),
			controls, container, gui = new dat.GUI( { width: 350 } ),
			options, spawnerOptions, particleSystem, mesh, rotation, position, mesh_rotation_x,
			cubeSineDriver_change, smoke_particles, smoke_color, delta;
		var stats;
		init();
		animate();
		function init() {
			//
			container = document.getElementById( 'container' );
			camera = new THREE.PerspectiveCamera( 28, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.z = 100;
			scene = new THREE.Scene();
			
			// The GPU Particle system extends THREE.Object3D, and so you can use it
			// as you would any other scene graph component.	Particle positions will be
			// relative to the position of the particle system, but you will probably only need one
			// system for your whole scene
			
			geometry = new THREE.CubeGeometry( 200, 200, 200 );
			material = new THREE.MeshLambertMaterial( { color: 0xaa6666, wireframe: false } );
			
			mesh = new THREE.Mesh( geometry, material );
			
			cubeSineDriver = 0;
			cubeSineDriver_change = 0.1;
			mesh_rotation_x = 0.01;
			mesh_rotation_y = 0.01;
			smoke_color = 0x00dddd;
			
			
			var params = {
				mesh_rotation_x: 0.01,
				mesh_rotation_y: 0.01,
				cubeSineDriver_change: 0.01,
				smoke_particles: 0.01,
				smoke_color: 0x00dddd,
			}
			
			light = new THREE.DirectionalLight(0xffffff, 1);
			light.position.set(-1,0,1);
			scene.add(light);
			
			gui.add( params, "mesh_rotation_x", -100, 100);
			gui.add( params, "mesh_rotation_y", -100, 100);
			gui.add( params, "smoke_particles", -100, 100);
			
			
			THREE.ImageUtils.crossOrigin = ''; //Need this to pull in crossdomain images from AWS

			smokeTexture = THREE.ImageUtils.loadTexture('https://s3-us-west-2.amazonaws.com/s.cdpn.io/95637/Smoke-Element.png');
			smokeMaterial = new THREE.MeshLambertMaterial({color: smoke_color, map: smokeTexture, transparent: true});
			smokeGeo = new THREE.PlaneGeometry(300,300);
			smokeParticles = [];
			
			for (p = 0; p < 150; p++) {
				var particle = new THREE.Mesh(smokeGeo,smokeMaterial);
				particle.position.set(Math.random()*500-250,Math.random()*500-250,Math.random()*1000-100);
				particle.rotation.z = Math.random() * 360;
				scene.add(particle);
				smokeParticles.push(particle);
			}
						
			//
			stats = new Stats();
			//
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );
			//
			window.addEventListener( 'resize', onWindowResize, false );
		}
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		function animate() {
			// note: three.js includes requestAnimationFrame shim
			stats.begin();
			delta = clock.getDelta();
			requestAnimationFrame( animate );
			evolveSmoke();
			render();
			stats.end();
		}
		function evolveSmoke() {
			smoke_particles = smokeParticles.length;
			while(smoke_particles--) {
				smokeParticles[smoke_particles].rotation.z += (delta * 0.2);
			}
	}

	function render() {
		mesh.rotation.x += mesh_rotation_x;
		mesh.rotation.y += mesh_rotation_y;
		cubeSineDriver += cubeSineDriver_change;
		mesh.position.z = 100 + (Math.sin(cubeSineDriver) * 500);
		renderer.render( scene, camera );
	}
	</script>
</body>

</html>