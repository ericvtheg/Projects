
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Homework 1 Part B</title>
		<meta charset="utf-8">
		<style>
			body {
			  	margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
<body>

<div id="container"></div>

	<script src="js/three.js"></script>
	<script id="vertexShader" type="x-shader/x-vertex">

	//vertex shaders needed to set up a varying for UV coordinates
	//provided by three.js
	uniform mat4 modelViewMatrix;
	uniform mat4 projectionMatrix;
	
	attribute vec3 position;
	attribute vec2 texCoords;
	
	//links vars between vertex shader and fragment shader
	varying vec2 UV;
	
	void main(){
		UV = texCoords;
		
		//multiply through projection matrix
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
	}
	</script>
	<script id="fragmentShader" type="x-shader/x-fragment">
	
	precision mediump float;
	
	//used to access stored texture data
	uniform sampler2D text_data;
	
	//resolution of texture
	uniform float rx;
	uniform float ry;
		
	uniform float mixVal;
	
	varying vec2 UV;	
	
	void main(){
		vec2 texel = vec2( 1.0 / rx, 1.0 / ry ); //gets texel by dividing 1 by resolutionx and resolutiony
		
		//kernel
		const mat3 Gx = mat3(.111, .111, .111, .111, .111, .111, .111, .111, .111);
		
		//gets the 3x3 neighborhood of a fragment 
		float tx0y0 = texture2D( text_data, UV + texel).r;
		float tx0y1 = texture2D( text_data, UV + texel).r;
		float tx0y2 = texture2D( text_data, UV + texel).r;

		float tx1y0 = texture2D( text_data, UV + texel).r;
		float tx1y1 = texture2D( text_data, UV + texel).r;
		float tx1y2 = texture2D( text_data, UV + texel).r;

		float tx2y0 = texture2D( text_data, UV + texel).r;
		float tx2y1 = texture2D( text_data, UV + texel).r;
		float tx2y2 = texture2D( text_data, UV + texel).r;
	
		//Does convolution of Gx and found 3x3 fragment
		float valueGx = Gx[0][0] * tx2y2 + Gx[1][0] * tx1y2 + Gx[2][0] * tx0y2 +
				Gx[0][1] * tx2y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx0y1 + Gx[0][2] * 
				tx2y0 + Gx[1][2] * tx1y0 + Gx[2][2] * tx0y0;
		
		
		vec4 edgePix = vec4(vec3(1.0) - vec3( valueGx ), 200.0);
		vec4 texPix = texture2D(text_data, UV);

		gl_FragColor = mix(texPix, edgePix, mixVal); 
	}
	</script>
	
	<script>
	
	var container;
	var camera, scene, renderer;

    var vs = document.getElementById( 'vertexShader' ).textContent;
    var fs = document.getElementById( 'fragmentShader' ).textContent;

	var mesh;
	var material;

	var texture1 = new THREE.TextureLoader().load( 'santacruz.jpg' );

	var mouseX = 0.0;
	var mouseY = 0.0;

	init();
	animate();
	
	function init(){
		container = document.getElementById('container');
		
		camera = new THREE.PerspectiveCamera( 60.0, window.innerWidth / window.innerHeight, 0.1, 50 );
		camera.position.z = 2;

		scene = new THREE.Scene();
		
		var geometry = new THREE.BufferGeometry();

		var vertices = new Float32Array( [
			-1.0, -1.0, 0.0,
			+1.0, -1.0, 0.0,
			+1.0, +1.0, 0.0,
	 
			-1.0, -1.0, 0.0,
			+1.0, +1.0, 0.0,
			-1.0, +1.0, 0.0,

		] );

		var texCoords = new Float32Array( [
			0.0, 0.0,
			1.0, 0.0,
			1.0, 1.0,
			
			0.0, 0.0,
			1.0, 1.0,
			0.0, 1.0,
		] );

		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'texCoords', new THREE.BufferAttribute( texCoords, 2 ) );


		// materials (ie, linking to the shader program)
		var uniforms = {
    			text_data: { type: "t", value: texture1  },
			rx: {type: "f", value: 1024/2},
			ry: {type: "f", value: 1024/2},
			mixVal: {type: "f", value: 0.5},
		};
	

     		material = new THREE.RawShaderMaterial( {
			uniforms: uniforms,
					vertexShader: vs,
					fragmentShader: fs,	
		} );


	    mesh = new THREE.Mesh( geometry, material );
		mesh.translateX(0.0);
		mesh.material.side = THREE.DoubleSide; //to render both sides of triangle
        scene.add( mesh );


		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0x999999 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );


		//make it so that resizing the browser window also resizes the scene
        window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener('mousemove', onDocumentMouseMove, false);
		
	}
	function animate() {

		requestAnimationFrame( animate );
		render();

	}

	function render() {

		var time = performance.now();

		mesh.material.uniforms.mixVal.value = mouseX;

		renderer.render( scene, camera );
	}

	//flipped mouseX and mouseY to have the y axis create effects
	//also makes it so the image gets brighter instead of darker
	function onDocumentMouseMove(event) {
		event.preventDefault();
		mouseY = (event.clientX / window.innerWidth) ;
		mouseX = -(event.clientY / window.innerHeight) ;
	}


	function onWindowResize( event ) {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}
	
	</script>
</body>
</html>