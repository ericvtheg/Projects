<html>
    <head>
        <title>CMPM163 Review</title>
        <style>
            body { margin: 0; }
        </style>
    </head>

    <body>

        <!-- Loading external libraries -->
        <script src="js/three.js"></script>
        <script src="js/orbit-controls.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">
		uniform mat4 modelMatrix;
		uniform mat4 viewMatrix;
		uniform mat4 projectionMatrix;
	
		attribute vec3 position;
		
		void main() {
			gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
		}
		</script>
		
		<script id="fragmentShader" type="x-shader/x-fragment">
		/*
		precision mediump float;
		uniform vec2 resolution;
		/*vec3 k_a = vec3(1.0,0.3,0.0);
		vec3 k_d = vec3(0.5,0.5,0.0);
		vec3 k_s = vec3(1.0,0.0,0.4);
		float alpha = 1.0;
		
		float sphereSDF(vec3 samplePoint) {
			return length(samplePoint) - 1.0;
		}
		
		float sceneSDF(vec3 samplePoint) {
			return sphereSDF(samplePoint);
		}
		
		float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
			float depth = start;
			for (int i = 0; i < 255; i++) {
				float dist = sceneSDF(eye.xyz + depth * marchingDirection.xyz);
				if (dist < 0.0001) {
					return depth;
				}
				depth += dist;
				if (depth >= end) {
					return end;
				}
			}
			return end;
		}
		
		vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
			vec2 xy = fragCoord.xy - size.xy / 2.0;
			float z = size.y / tan(radians(fieldOfView) / 2.0);
			return normalize(vec3(xy, -z));
		}
	
		vec3 estimateNormal(vec3 p) {
			return normalize(vec3(
				sceneSDF(vec3(p.x + 0.0001, p.y, p.z)) - sceneSDF(vec3(p.x - 0.0001, p.y, p.z)),
				sceneSDF(vec3(p.x, p.y + 0.0001, p.z)) - sceneSDF(vec3(p.x, p.y - 0.0001, p.z)),
				sceneSDF(vec3(p.x, p.y, p.z  + 0.0001)) - sceneSDF(vec3(p.x, p.y, p.z - 0.0001))
			));
		}

		vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {
			vec3 N = estimateNormal(p.xyz);
			vec3 L = normalize(lightPos.xyz - p.xyz);
			vec3 V = normalize(eye.xyz - p.xyz);
			vec3 R = normalize(reflect(-L, N));
    
			float dotLN = dot(L, N);
			float dotRV = dot(R, V);
    
			if (dotLN < 0.0) {
				// Light not visible from this point on the surface
				return vec3(0.0, 0.0, 0.0);
			} 
    
			if (dotRV < 0.0) {
			// Light reflection in opposite direction as viewer, apply only diffuse
			// component
				return lightIntensity * (k_d * dotLN);
			}
			return lightIntensity * (k_d * dotLN + k_s * pow(abs(dotRV), alpha));
		}
		
		vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {
			const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);
			vec3 color = ambientLight * k_a;
    
			vec3 light1Pos = vec3(0.0,
                          10.0,
                          0.0);
						  
			vec3 light1Intensity = vec3(1.0, 1.0, 1.0);
    
			color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                  light1Pos,
                                  light1Intensity);
    
			vec3 light2Pos = vec3(2.0,
                          2.0,
                          2.0);
			vec3 light2Intensity = vec3(0.4, 0.4, 0.4);
    
			color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                  light2Pos,
                                  light2Intensity);    
			return color;
		}
		void main(){
			vec3 dir = rayDirection(45.0, resolution.xy, gl_FragCoord.xy);
			vec3 eye = vec3(0.0, 0.0, 5.0);
			float dist = shortestDistanceToSurface(eye.xyz, dir.xyz, 0.0, 1000.0);
    
			if (dist > 1000.0 - 0.0001) {
				// Didn't hit anything
				gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
			} else {
    
			// The closest point on the surface to the eyepoint along the view ray
			vec3 p = eye.xyz + dist * dir.xyz;
    
			vec3 K_a = vec3(0.2, 0.2, 0.2); //ambient
			vec3 K_d = vec3(0.7, 0.2, 0.2); 
			vec3 K_s = vec3(1.0, 1.0, 1.0);
			float shininess = 10.0;
    
			//vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);
    
			gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
			}
			
		}*/
		
		void main(){
			gl_FragColor = vec4(1.0,0.0,0.0,1.0);
		}
		</script>
		
		
		<script>
			var vs = document.getElementById( 'vertexShader' ).textContent;
			var fs = document.getElementById( 'fragmentShader' ).textContent;
			
            // 0. Create a renderer
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

			var width = window.innerHeight;
			var height = window.innerWidth;

            // 1. Create a Scene
            var scene = new THREE.Scene();

            // 1.1 Create a camera
            var camera = new THREE.OrthographicCamera(width/-2.0, width/2.0, height/2.0, height/-2.0, 1, 1000);

            // 2. Create a cube
            var geometry = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight);
			
			var uniforms = {
				resolution: { type: "v2", value: new THREE.Vector2() }
			};
			uniforms.resolution.value.x = window.innerWidth;
			uniforms.resolution.value.y = window.innerHeight;
			
			var material = new THREE.RawShaderMaterial( {
				vertexShader: vs,
				fragmentShader: fs,	
				uniforms: uniforms,
			} );
			
			var plane = new THREE.Mesh( geometry, material );
			
			scene.add( plane );
			
			function animate() {
		
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}
			
			animate();
        </script>

    </body>
</html>
